---
title: "코드를 압축하는 기술, 인코딩 기법"
date: 2025-07-17 13:00:00 +0900
categories: [CS]
tags: [인코딩, 자료구조, 비트마스크, BFS, 최적화]
---

## '인코딩', 효율적 데이터 처리의 첫걸음 {: #encoding-section}

알고리즘 문제를 풀다 보면, 여러 정보를 하나의 변수에 담아 처리해야 할 때가 종종 있습니다. 이때, 여러 자료구조를 조합하여 복잡하게 관리하는 대신, **하나의 변수에 정보를 영리하게 압축**하는 기법을 사용할 수 있습니다. 이것이 바로 **인코딩(Encoding)**의 시작입니다.

'인코딩'은 단순히 문제 풀이 트릭이 아닙니다. 이것은 '주어진 정보를 어떻게 더 적은 변수와 더 단순한 자료구조로 표현할 것인가'에 대한 고민이며, 효율적인 코드를 작성하기 위한 아주 중요한 태도입니다. 몇 가지 구체적인 예시를 통해 인코딩의 힘을 느껴보겠습니다.


### 예시 1: 2차원 좌표와 BFS
좌표평면 위에서 BFS(너비 우선 탐색)를 실행하는 상황을 생각해 봅시다. 보통 큐에 현재 위치의 좌표 (row, col)을 저장하기 위해 Queue<int[]> 나 Queue<Point> 같은 자료구조를 사용합니다.

```java
// 일반적인 방식
Queue<int[]> queue = new ArrayDeque<>();
queue.offer(new int[]{currentRow, currentCol});
int[] pos = queue.poll();
int r = pos[0];
int c = pos[1];
```

이 방식은 매번 `new int[2]`와 같이 객체를 생성하는 오버헤드가 있습니다. 만약 격자의 가로 크기를 `C`라고 할 때, 좌표를 아래와 같이 하나의 정수로 인코딩하면 어떨까요?

* **인코딩:** `int encoded = row * C + col;`
* **디코딩:** `int row = encoded / C;`, `int col = encoded % C;`

이렇게 하면 `Queue<Integer>` 하나만으로 좌표를 관리할 수 있습니다. 불필요한 객체 생성을 줄여 미세하지만 더 빠른 속도와 더 적은 메모리를 사용하게 되죠.


### 예시 2: 비트마스크와 집합의 상태

DP(동적 계획법)나 완전 탐색 문제에서는 여러 개의 아이템 중 일부를 선택한 '상태'를 표현해야 할 때가 많습니다. 예를 들어, N개의 아이템이 있을 때 각 아이템을 포함하거나 포함하지 않는 모든 부분집합을 어떻게 표현할 수 있을까요?

이때 **비트마스크(Bitmask)**가 바로 정수를 이용한 인코딩의 정점입니다. 정수 하나를 비트(0과 1)의 배열로 보고, `i`번째 비트가 1이면 'i번째 아이템을 포함한다'고 약속하는 것입니다.

* `{0, 2, 3}`번 아이템을 포함하는 집합
* **인코딩:** `(1 << 0) | (1 << 2) | (1 << 3)` → `1 | 4 | 8` → `13` (이진수 `1101`)

정수 `13` 하나로 어떤 아이템들이 선택되었는지에 대한 모든 정보를 표현할 수 있습니다. 이는 집합을 배열이나 리스트로 관리하는 것보다 훨씬 빠르고 간결하여, 특정 유형의 복잡한 문제를 해결할 수 있습니다.


## 마무리: 인코딩을 통해 더 효율적으로

오늘 소개한 예시들은 모두 하나의 공통점을 가집니다. **'어떻게 하면 정보를 더 영리하게, 더 근본적인 형태로 표현할까?'** 라는 고민에서 출발했다는 점입니다.

인코딩이라는 것이 생각보다 별거 아니죠? 하나의 변수에 여러가지 정보를 담는 것을 고민하다보면, 보다 더 효율적인 코드를 작성할 수 있을 것입니다.

궁금한 점이 있으시면 편하게 댓글 남겨주세요.