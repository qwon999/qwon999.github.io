---
title: "[백준 11286] 절댓값 힙 (Java) - 우선순위 큐 하나로 해결하기(인코딩 활용)"
date: 2025-07-17 16:30:00 +0900
categories: [Algorithm]
tags: [백준, 우선순위큐, 힙, 자료구조, 인코딩, 비트마스크, 좌표]
---

이 풀이법에 사용된 인코딩 기법에 대해 더 자세히 알고 싶다면, [코드를 압축하는 기술, 인코딩 기법]({% post_url 2025-07-17-encoding-techniques %}) 게시물을 참고해 주세요.



## 문제 링크

[https://www.acmicpc.net/problem/11286](https://www.acmicpc.net/problem/11286)

## 핵심 아이디어: 우선순위 큐 (Heap)
이 문제는 커스텀 정렬 조건이 있는 값을 빠르게 찾아야 하므로, 우선순위 큐(Heap)를 사용하는 전형적인 문제입니다. 문제의 조건은 다음과 같습니다.

1.  절댓값이 가장 작은 값을 우선으로 한다.
2.  만약 절댓값이 같다면, 원래 값이 더 작은 수(음수)를 우선으로 한다.
   
## 두 개의 힙, 꼭 필요할까?
이러한 커스텀 정렬 조건을 처리하기 위해 많은 분들이 두 개의 우선순위 큐를 사용합니다.

* **최소 힙 (Min Heap):** 양수를 저장
* **최대 힙 (Max Heap):** 음수를 저장 (절댓값 기준으로는 최소 힙처럼 동작)

그리고 값을 꺼낼 때마다 두 힙의 top을 비교하여 조건에 맞는 값을 꺼내는 방식입니다. 이 방법도 훌륭한 풀이지만, 저는 문득 이런 생각이 들었습니다.

> "하나의 우선순위 큐에 값을 **잘** 넣어서 이 모든 조건을 자동으로 처리하게 할 수는 없을까?"

## 숫자를 '인코딩'하여 힙에 넣기
힙을 하나만 사용하는 것이 두개를 사용하는 것보다 효율적인 것은 당연하겠죠? 그렇다면 어떻게하면 하나의 힙에서 관리가 가능할까요?

Java의 `PriorityQueue`는 기본적으로 최소 힙으로 동작합니다. 즉, 가장 작은 값이 최상단에 위치합니다. 이 기본 동작을 우리가 원하는 '절댓값 우선, 다음으로 음수 우선' 순서로 바꾸기 위해, 큐에 값을 넣기 전에 간단한 트릭, 즉 **인코딩(Encoding)**을 사용했습니다.

핵심 아이디어는 다음과 같습니다.
1.  **양수 `x`는 `x * 10`으로 변환하여 저장한다.**
2.  **음수 `x`는 `|x| * 10 - 1`으로 변환하여 저장한다.**

예를 들어, `120`과 `-120`이 입력되었다고 생각해 봅시다.
* `120` (양수) → `120 * 10` → **`1200`**
* `-120` (음수) → `|-120| * 10 - 1` → `1200 - 1` → **`1199`**

이렇게 변환된 두 값을 우선순위 큐에 넣으면, 더 작은 값인 `1199`가 `1200`보다 높은 우선순위를 갖게 됩니다. 즉, **절댓값이 같을 때 음수가 양수보다 먼저 나오게 되는 조건**이 자연스럽게 만족됩니다. 절댓값 자체가 다른 경우에는 `* 10`을 해주었기 때문에 원래의 대소 관계가 그대로 유지됩니다.

## '디코딩'하여 원래 값으로 되돌리기
이제 우선순위 큐에서 값을 꺼낼 때는, 인코딩된 값을 다시 원래의 값으로 되돌리는 **디코딩(Decoding)** 과정이 필요합니다. 이 또한 간단한 규칙으로 해결할 수 있습니다.

1.  **꺼낸 값 `v`를 10으로 나눈 나머지가 0이라면, 원래 양수였다는 의미이다.**
    * 따라서 원래 값은 `v / 10` 입니다. (예: `1200 -> 120`)
2.  **나머지가 0이 아니라면 (우리의 규칙상 9), 원래 음수였다는 의미이다.**
    * 원래 값은 `-(v / 10 + 1)` 입니다. (예: `1199 -> -(119 + 1) -> -120`)

이 두 가지 규칙만으로 우리는 `Long` 타입의 우선순위 큐 하나만 가지고 '절댓값 힙'의 모든 조건을 만족시킬 수 있습니다.

## 전체코드
```java
public class Main {
	
	public static void main(String[] args) throws IOException {
		BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
		BufferedWriter bw = new BufferedWriter(new OutputStreamWriter(System.out));
		
        // long 타입으로 선언하여 곱셈 시 오버플로우를 방지합니다.
		PriorityQueue<Long> pq = new PriorityQueue<>();
		
		int N = Integer.parseInt(br.readLine());
		
		for(int i = 0 ; i < N ; i++) {
			long temp = Long.parseLong(br.readLine());
			
			if(temp == 0) { // 0이 입력된 경우
				if(pq.isEmpty()) {
					bw.write(0 + "\n");
				} else {
					long ans = pq.poll(); // 가장 작은 값(인코딩된)을 꺼냄
					
                    // 디코딩 과정
					if(ans % 10 == 0) { // 나머지가 0이면 원래 양수
						bw.write((ans / 10) + "\n");
					} else { // 나머지가 9이면 원래 음수
						bw.write((-1 * (ans / 10 + 1)) + "\n");
					}
				}
			} else if(temp > 0) { // 양수가 입력된 경우
				pq.offer(temp * 10); // 인코딩하여 삽입
			} else { // 음수가 입력된 경우
				pq.offer(temp * (-10) - 1); // 인코딩하여 삽입
			}		
		}
		bw.flush();		
	}
}

```

궁금한 점이 있으시면 편하게 댓글 남겨주세요.